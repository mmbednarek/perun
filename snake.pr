// Clib functions
extern fn rand(): i32;
extern fn malloc(size: i64): rawptr;

// SDL functions and constants
extern fn SDL_Init(flags: i32): i32;
extern fn SDL_CreateWindow(title: rawptr, x: i32, y: i32, w: i32, h: i32, flags: i32): rawptr;
extern fn SDL_PollEvent(event: rawptr): i32;
extern fn SDL_CreateRenderer(wnd: rawptr, idk: i32, flags: i32): rawptr;
extern fn SDL_RenderClear(renderer: rawptr): i32;
extern fn SDL_RenderPresent(renderer: rawptr);
extern fn SDL_Delay(ms: i32);
extern fn SDL_SetRenderDrawColor(renderer: rawptr, r: i8, g: i8, b: i8, a: i8): i32;
extern fn SDL_RenderFillRect(renderer: rawptr, rect: rawptr): i32;

const SDL_INIT_EVERYTHING = 62001;
const SDL_WINDOWPOS_CENTERED = 805240832;

// Perun corelib functions
fn print(msg: rawptr);
fn print_int(in_value: i32);

const WINDOW_WIDTH = 800;
const WINDOW_HEIGHT = 600;

fn main() : i32 {
    if SDL_Init(SDL_INIT_EVERYTHING) != 0 {
        print("failed to initialize SDL\n");
        return 1;
    }

    var wnd_handle = SDL_CreateWindow(
        "Snake Game",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        WINDOW_WIDTH,
        WINDOW_HEIGHT,
        0
    );

    var event_ptr = malloc(56);
    var is_running: bool = 1;
    var renderer_handle = SDL_CreateRenderer(wnd_handle, 0-1, 2);
    var rect = malloc(16);
    var snake = malloc(256*16);
    var head: i32 = 2;
    var speed = 2;
    var target_x = rand() % (WINDOW_WIDTH-32);
    var target_y = rand() % (WINDOW_HEIGHT-32);

    var x = 32;
    var index = 0;
    while index <= head {
        snake[4*index + 0] = x;
        snake[4*index + 1] = 128;
        snake[4*index + 2] = 0;
        snake[4*index + 3] = 0;

        x = x + 32;
        index = index + 1;
    }

    rect[2] = i32(32);
    rect[3] = i32(32);

    while is_running {
        while SDL_PollEvent(event_ptr) {
            var event_type: i32 = *event_ptr;

            if event_type == 256 {
                is_running = 0;
            }
            if event_type == 768 {
                var key_type: i32 = event_ptr[4];

                var motion_x: i32 = snake[4*head + 2];
                var motion_y: i32 = snake[4*head + 3];

                // Up Event
                if key_type == 26 && motion_y <= 0 {
                    motion_y = 0-speed;
                    motion_x = 0;
                }
                // Down Event
                if key_type == 22 && motion_y >= 0 {
                    motion_y = speed;
                    motion_x = 0;
                }
                // Left Event
                if key_type == 4 && motion_x <= 0 {
                    motion_y = 0;
                    motion_x = 0-speed;
                }
                // Right Event
                if key_type == 7 && motion_x >= 0 {
                    motion_y = 0;
                    motion_x = speed;
                }

                snake[4*head + 2] = motion_x;
                snake[4*head + 3] = motion_y;
            }
        }

        var index = 0;
        while index < head {
            var x: i32 = snake[4*index + 0];
            var y: i32 = snake[4*index + 1];
            var next_x: i32 = snake[4*(index+1) + 0];
            var next_y: i32 = snake[4*(index+1) + 1];
            var motion_x: i32 = snake[4*index + 2];
            var motion_y: i32 = snake[4*index + 3];
            var next_motion_x: i32 = snake[4*(index+1) + 2];
            var next_motion_y: i32 = snake[4*(index+1) + 3];

            if next_motion_x != 0 && (motion_y >= 0 && y >= next_y || motion_y <= 0 && y <= next_y) {
                if next_motion_x > 0 {
                    snake[4*index + 0] = next_x-32;
                }
                if next_motion_x < 0 {
                    snake[4*index + 0] = next_x+32;
                }
                snake[4*index + 1] = next_y;
                snake[4*index + 2] = next_motion_x;
                snake[4*index + 3] = next_motion_y;
            }

            if next_motion_y != 0 && (motion_x >= 0 && x >= next_x || motion_x <= 0 && x <= next_x) {
                snake[4*index + 0] = next_x;

                if next_motion_y > 0 {
                    snake[4*index + 1] = next_y-32;
                }
                if next_motion_y < 0 {
                    snake[4*index + 1] = next_y+32;
                }

                snake[4*index + 2] = next_motion_x;
                snake[4*index + 3] = next_motion_y;
            }

            index = index + 1;
        }

        index = 0;
        while index <= head {
            snake[4*index] = i32(snake[4*index]) + i32(snake[4*index + 2]);
            snake[4*index + 1] = i32(snake[4*index + 1]) + i32(snake[4*index + 3]);
            index = index + 1;
        }

        // Check if reached target AABB
        var x: i32 = snake[4*head];
        var y: i32 = snake[4*head + 1];

        if x < target_x + 32 && x + 32 > target_x && y < target_y + 32 && y + 32 > target_y {
            target_x = rand() % (WINDOW_WIDTH-32);
            target_y = rand() % (WINDOW_HEIGHT-32);
            speed = speed + 1;

            print("new apple position: ");
            print_int(target_x);
            print(", ");
            print_int(target_y);
            print("\n");

            if head < 255 {
                head = head + 1;
                snake[4*head] = i32(snake[4*(head-1)]);
                snake[4*head + 1] = i32(snake[4*(head-1) + 1]);
                snake[4*head + 2] = i32(snake[4*(head-1) + 2]);
                snake[4*head + 3] = i32(snake[4*(head-1) + 3]);
            }
        }

        SDL_RenderClear(renderer_handle);

        SDL_SetRenderDrawColor(renderer_handle, 255, 0, 0, 255);

        index = 0;
        while index <= head {
            rect[0] = i32(snake[4*index]);
            rect[1] = i32(snake[4*index + 1]);
            SDL_RenderFillRect(renderer_handle, rect);
            index = index + 1;
        }

        SDL_SetRenderDrawColor(renderer_handle, 0, 255, 0, 255);
        rect[0] = target_x;
        rect[1] = target_y;
        SDL_RenderFillRect(renderer_handle, rect);

        SDL_SetRenderDrawColor(renderer_handle, 0, 0, 0, 255);

        SDL_RenderPresent(renderer_handle);
        SDL_Delay(15);
    }

    return 0;
}
